package process

import (
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/influxdata/influxdb/client/v2"
	"github.com/sirupsen/logrus"

	"github.com/vincoll/vigie/pkg/teststruct"
	"github.com/vincoll/vigie/pkg/tsdb"
	"github.com/vincoll/vigie/pkg/utils"
)

// updateParentTestStruct permet de rafraichir l'état de Structures (TestSuites,TC)
// Ce changement d'état est du à un changement d'état d'une TStep
func updateParentTestStruct(task teststruct.Task) {

	if task.TestStep.GetStatus() != teststruct.Success {

		// If one tStep is KO => Parents are KO too
		task.TestCase.SetStatus(teststruct.Failure)
		task.TestSuite.SetStatus(teststruct.Failure)
		return
	} else {
		// Success => Update TC (check if there is any teststep KO left in TC)
		// UpdateStatus TC
		statusTC := task.TestCase.UpdateStatus()
		// UpdateStatus TestSuites
		if statusTC == false {
			// TC ResultStatus is False then
			// TestSuite is set to false immediately
			task.TestSuite.SetStatus(teststruct.Failure)
		} else {
			// This precise TestCase is OK,
			// But we need to check the others TCs in this TestSuites
			// to check if at least one of the TCs remains KO
			task.TestSuite.UpdateStatus()
		}
	}

}

func writeTaskToDB(task teststruct.Task) {

	task.RLockAll()

	// Push the Step Results to InfluxDB
	utils.Log.WithFields(logrus.Fields{
		"package":   "process",
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
		"testsuite": task.TestSuite.Name,
	}).Debug("Push task result into DB")

	// Create a Time series data aka points for InfluxDB
	// TAGS are used to identify a task in the DB for later queries
	taskTags := map[string]string{
		"testsuite": task.TestSuite.Name,
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
	}

	var wg sync.WaitGroup
	wg.Add(len(task.TestStep.VigieResults))
	for _, vigieRes := range task.TestStep.VigieResults {

		go func(vr teststruct.VigieResult) {
			insertTestToDB(taskTags, vr, task.TestStep.LastAttempt)
			wg.Done()
		}(vigieRes)

	}
	wg.Wait()

	task.RUnlockAll()
}

func insertTestToDB(taskTags map[string]string, vr teststruct.VigieResult, lastAttemptTime time.Time) {

	start := time.Now()

	// DIRTY for now => Probeinfo should be a clean go struct in VigieResponse.
	pi := vr.ProbeResult["probeinfo"].(map[string]interface{})
	convRT, _ := time.ParseDuration(fmt.Sprintf("%v", pi["responsetime"]))

	// FIELDS are the points value generated by the probe
	// For each task 3 fields will be write (ResultStatus, ResponseTime, Returned probe result)
	var taskFields map[string]interface{}

	if vr.Status.IsTimeMesureable() {
		taskFields = map[string]interface{}{
			// ResultStatus Teststep (string detail)
			"status": vr.Status,
			// ResponseTime (If relevant: float64 second based)
			"responsetime": convRT.Seconds(),
			// Returned probe result (string: raw json result)
			"msg": msgtojson(vr),
			// Subtest
			"subtest": pi["subtest"],
		}
	} else {
		taskFields = map[string]interface{}{
			// ResultStatus Teststep (string detail)
			"status": vr.Status,
			// ResponseTime => No time.

			// Returned probe result (string: raw json result)
			"msg": msgtojson(vr),
			// Subtest
			"subtest": pi["subtest"],
		}
	}

	// POINT
	taskNP, errnp := client.NewPoint("vigie_teststep", taskTags, taskFields, lastAttemptTime)
	if errnp != nil {
		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "process",
		}).Errorf("Cannot generate Influx point: %s", errnp)
	}

	// Write to InfluxDB
	errwdb := tsdb.InfluxInst.WritePoint(taskNP, "")
	if errwdb != nil {

		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "process",
		}).Error("Cannot write Influx point into DB: ", errwdb)
	}

	// Push the Step Results to InfluxDB
	utils.Log.WithFields(logrus.Fields{
		"package":   "process",
		"teststep":  taskTags["teststep"],
		"testcase":  taskTags["testcase"],
		"testsuite": taskTags["testsuite"],
	}).Tracef("Time to complete insertIntoDB: %s", time.Since(start))

}

// updateTestStateToDB updateParentTestStruct only testcase and testsuite status
func updateTestStateToDB(task teststruct.Task) {

	start := time.Now()

	task.RLockAll()

	// Create a Time series data aka points for InfluxDB
	// TAGS are used to identify a task in the DB for later Queries
	taskTags := map[string]string{
		"testsuite": task.TestSuite.Name,
		"testcase":  task.TestCase.Name,
	}

	// FIELDS are the points value generated by the Probe
	testCaseField := map[string]interface{}{
		"status": task.TestCase.Status,
	}

	// FIELDS are the points value generated by the Probe
	testSuiteField := map[string]interface{}{
		"status": task.TestSuite.Status,
	}

	// POINT TestCase
	taskTC, err := client.NewPoint("vigie_testcase", taskTags, testCaseField, task.TestStep.LastAttempt)
	if err != nil {
	}

	// Write TestCase to InfluxDB
	_ = tsdb.InfluxInst.WritePoint(taskTC, "")

	// POINT TestSuite
	taskTS, err := client.NewPoint("vigie_testsuite", taskTags, testSuiteField, task.TestStep.LastAttempt)
	if err != nil {
	}

	// Write to InfluxDB TestSuite
	errwdb := tsdb.InfluxInst.WritePoint(taskTS, "")
	if errwdb != nil {

		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "process",
		}).Error("Cannot write Influx point into DB: ", errwdb)
	}

	utils.Log.WithFields(logrus.Fields{
		"package":   "process",
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
		"testsuite": task.TestSuite.Name,
	}).Tracef("Time to complete insertIntoDB: %s", time.Since(start))

	task.RUnlockAll()
}

func msgtojson(vr teststruct.VigieResult) string {

	data, err := json.Marshal(vr)
	if err != nil {
		fmt.Printf("marshal failed: %s", err)
	}

	return string(data)
}
