package tsdb

import (
	"fmt"
	"github.com/vincoll/vigie/pkg/teststruct"
	"net"
	"strings"
	"sync"
	"time"

	"github.com/influxdata/influxdb/client/v2"
	"github.com/sirupsen/logrus"
	"github.com/vincoll/vigie/pkg/utils"
)

type vInfluxDB struct {
	conf ConfInfluxDB
}

func NewInfluxDB(conf ConfInfluxDB) (*vInfluxDB, error) {

	idb := vInfluxDB{conf: conf}

	err := idb.validateConnection()
	if err != nil {
		return nil, fmt.Errorf("failed to validate a connection with %q: %s", conf.Addr, err)
	}

	utils.Log.WithFields(logrus.Fields{
		"component": "tsdb",
		"host":      conf.Addr,
		"db":        conf.Database,
	}).Infof(fmt.Sprintln("Vigie TsdbEndpoint connection succeed"))

	return &idb, nil
}

func (idb *vInfluxDB) Name() string {
	return "influxdb"
}

func (idb *vInfluxDB) validateConnection() error {

	success := false
	var res []client.Result
	// Loop to infinity as long as the base has not responded
	for success == false {

		r, err := idb.queryDB("SHOW DATABASES")
		if err != nil {

			host := strings.Split(idb.conf.Addr, "//")[1]
			_, tcperr := net.Dial("tcp", host)

			if tcperr != nil {

				utils.Log.WithFields(logrus.Fields{
					"component": "tsdb",
					"host":      idb.conf.Addr,
					"db":        idb.conf.Database,
				}).Errorf("cannot reach InfluxDB via TCP %s: %s. Next try : 5sec", host, tcperr)

			} else {
				utils.Log.WithFields(logrus.Fields{
					"component": "tsdb",
					"host":      idb.conf.Addr,
					"db":        idb.conf.Database,
				}).Errorf("cannot reach InfluxDB %s: %s. Next try : 5sec", host, err)
			}
			time.Sleep(5 * time.Second)

		} else {
			res = r
			success = true
		}
	}

	// Check if the database name provided in vigie.toml exists in this influxdb instance
	for _, row := range res[0].Series[0].Values {
		str, _ := row[0].(string)
		if str == idb.conf.Database {
			return nil
		}
	}

	return fmt.Errorf("vInfluxDB user: %q can not access DB: %q", idb.conf.User, idb.conf.Database)
}

func (idb *vInfluxDB) WritePoint(task teststruct.Task) error {

	task.RLockAll()

	// Push the Step Results to InfluxDB
	utils.Log.WithFields(logrus.Fields{
		"package":   "tsdb_influx",
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
		"testsuite": task.TestSuite.Name,
	}).Debug("Push task result into ", idb.Name())

	// Create a Time series data aka points for InfluxDB
	// TAGS are used to identify a task in the DB for later queries
	taskTags := map[string]string{
		"testsuite": task.TestSuite.Name,
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
	}

	var wg sync.WaitGroup
	wg.Add(len(task.TestStep.VigieResults))
	for _, vigieRes := range task.TestStep.VigieResults {

		go func(vr teststruct.VigieResult) {
			idb.insertTestToDB(taskTags, vr, task.TestStep.LastAttempt)
			wg.Done()
		}(vigieRes)

	}
	wg.Wait()

	task.RUnlockAll()
	return nil

}

func (idb *vInfluxDB) UpdateTestState(task teststruct.Task) error {

	start := time.Now()

	task.RLockAll()

	// Create a Time series data aka points for InfluxDB
	// TAGS are used to identify a task in the DB for later Queries
	taskTags := map[string]string{
		"testsuite": task.TestSuite.Name,
		"testcase":  task.TestCase.Name,
	}

	// FIELDS are the points value generated by the Probe
	testCaseField := map[string]interface{}{
		"status": task.TestCase.Status,
	}

	// FIELDS are the points value generated by the Probe
	testSuiteField := map[string]interface{}{
		"status": task.TestSuite.Status,
	}

	// POINT TestCase
	taskTC, err := client.NewPoint("vigie_testcase", taskTags, testCaseField, task.TestStep.LastAttempt)
	if err != nil {
	}

	// Write TestCase to InfluxDB
	_ = idb.writePointToInfluxDB(taskTC, "")

	// POINT TestSuite
	taskTS, err := client.NewPoint("vigie_testsuite", taskTags, testSuiteField, task.TestStep.LastAttempt)
	if err != nil {
	}

	// Write to InfluxDB TestSuite
	errwdb := idb.writePointToInfluxDB(taskTS, "")
	if errwdb != nil {

		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "process",
		}).Error("Cannot write Influx point into DB: ", errwdb)
	}

	utils.Log.WithFields(logrus.Fields{
		"package":   "process",
		"testcase":  task.TestCase.Name,
		"teststep":  task.TestStep.Name,
		"testsuite": task.TestSuite.Name,
	}).Tracef("Time to complete insertIntoDB: %s", time.Since(start))

	task.RUnlockAll()

	return nil
}

func (idb *vInfluxDB) insertTestToDB(taskTags map[string]string, vr teststruct.VigieResult, lastAttemptTime time.Time) {

	start := time.Now()
	// Generate Influx Payload
	influxPayload, err := idb.genPayload(taskTags, vr, lastAttemptTime)
	if err != nil {
		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "tsdb_influxdb",
		}).Errorf("Cannot generate Influx point: %s", err)
		return
	}

	// Write to InfluxDB
	errwdb := idb.writePointToInfluxDB(influxPayload, "")
	if errwdb != nil {

		utils.Log.WithFields(logrus.Fields{
			"teststep":  taskTags["teststep"],
			"testcase":  taskTags["testcase"],
			"testsuite": taskTags["testsuite"],
			"package":   "tsdb_influxdb",
		}).Error("Cannot write Influx point into DB: ", errwdb)
		return
	}

	utils.Log.WithFields(logrus.Fields{
		"package":   "tsdb_influxdb",
		"teststep":  taskTags["teststep"],
		"testcase":  taskTags["testcase"],
		"testsuite": taskTags["testsuite"],
	}).Tracef("Time to complete insert Into InfluxDB: %s", time.Since(start))

}

func (idb *vInfluxDB) genPayload(taskTags map[string]string, vr teststruct.VigieResult, lastAttemptTime time.Time) (*client.Point, error) {

	// FIELDS are the points value generated by the probe
	// For each task 3 fields will be write (ResultStatus, ResponseTime, Returned probe result)
	var taskFields map[string]interface{}

	if vr.Status.IsTimeMesureable() {
		taskFields = map[string]interface{}{
			// ResultStatus Teststep (string detail)
			"status": vr.Status.Int(),
			// ResponseTime (If relevant: float64 second based)
			"responsetime": vr.ProbeInfo.ResponseTime.Seconds(),
			// Returned probe result (string: raw json result)
			"msg": msgtojson(vr),
			// Subtest
			"subtest": vr.ProbeInfo.SubTest,
		}
	} else {
		taskFields = map[string]interface{}{
			// ResultStatus Teststep (string detail)
			"status": vr.Status.Int(),
			// ResponseTime => No time.

			// Returned probe result (string: raw json result)
			"msg": msgtojson(vr),
			// Subtest
			"subtest": vr.ProbeInfo.SubTest,
		}
	}

	// POINT
	taskNP, errnp := client.NewPoint("vigie_teststep", taskTags, taskFields, lastAttemptTime)

	return taskNP, errnp
}

func (idb *vInfluxDB) createClient() (client.Client, error) {

	// Create a new HTTPClient
	c, err := client.NewHTTPClient(client.HTTPConfig{
		Addr:     idb.conf.Addr,
		Username: idb.conf.User,
		Password: idb.conf.Password,
	})
	if err != nil {
		return nil, fmt.Errorf("error creating vInfluxDB Client: %s", err.Error())
	}
	return c, nil
}

//
//
//

// queryDB convenience function to query the database
func (idb *vInfluxDB) queryDB(cmd string) (res []client.Result, err error) {

	clnt, err := idb.createClient()
	if err != nil {
		return nil, err
	}
	defer clnt.Close()

	q := client.Query{
		Command:  cmd,
		Database: idb.conf.Database,
	}

	if response, err := clnt.Query(q); err == nil {
		if response.Error() != nil {
			return res, response.Error()
		}
		res = response.Results
	} else {
		return res, fmt.Errorf("error during vInfluxDB Query: %s", err.Error())
	}
	return res, nil
}

func (idb *vInfluxDB) batchPoint(retPol string) (client.BatchPoints, error) {

	bp, err := client.NewBatchPoints(client.BatchPointsConfig{
		Database:        idb.conf.Database,
		Precision:       "ms",
		RetentionPolicy: retPol,
	})
	if err != nil {
		return nil, err
	}
	return bp, nil
}

// writePointToInfluxDB convenience function to insert data into the database
func (idb *vInfluxDB) writePointToInfluxDB(np *client.Point, retPol string) (err error) {

	clnt, err := idb.createClient()
	if err != nil {
		utils.Log.WithFields(logrus.Fields{
			"package": "influxdb",
		}).Error("Cannot create Influx client: ", err)
		return err
	}
	defer clnt.Close()
	bp, _ := idb.batchPoint(retPol)

	bp.AddPoint(np)
	if err := clnt.Write(bp); err != nil {
		return err
	}

	return nil
}
